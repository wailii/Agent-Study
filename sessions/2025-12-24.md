# 学习笔记 - 2025-12-24

## 1. 会话概览 (Session Overview)

- 日期: 2025-12-24
- 时长: ~80 分钟
- 主要主题:
  - 学习 C.2 Supervisor（监督者模式）与 Router Agent 心智模型
  - 基于真实工作流（Gem1/Gem2/设计AI/Gem3）设计路由与纠错规则
  - 提炼可落地的 Supervisor system prompt 模板与决策流程图

---

## 2. 核心交互记录 (Interaction Log)

### 主题 1: Supervisor vs Handoffs 的区别与适用场景

#### 我的问题/场景 (My Question/Scenario)
在已经掌握 C.1 Handoffs（多智能体路由与移交）的基础上，希望进一步理解 C.2 Supervisor（监督者模式），并弄清楚：
- Supervisor 和 Handoffs 在架构上的本质区别是什么？
- 在自己的 Gem1/Gem2/设计AI/Gem3 工作流里，哪些场景适合引入 Supervisor？

#### 我的初始理解 (My Initial Understanding)
- [✓] 直觉认为：Handoffs 更像"按部就班"的固定流程，Supervisor 更像"按需选择路径"的动态调度。
- [✓] 能给出具体例子：领导只改首页配色的需求，其实不需要走 Gem1/Gem2，直接丢给设计AI即可。
- [ ] 但还不清楚 Supervisor 在多轮流程中到底负责哪些决策，以及如何避免误判路由导致方向走偏。

#### 提供的解释 (Explanation Given)
- Handoffs 模式：
  - 更像"流水线"：A → B → C → D，路径在设计时就写死。
  - 适合每一步都必经且依赖关系清晰的线性流程。
- Supervisor 模式：
  - 更像"呼叫中心主管"或"工单调度系统"：根据当前任务类型、上下文、已有进展动态决定下一步派给谁。
  - 核心职责包括：
    - 路由决策（Routing）：决定下一步调用哪个 Agent。
    - 状态管理（State Tracking）：记录已经走过哪些阶段、拿到哪些输出。
    - 终止判断（Completion Check）：决定任务何时可以收工。
- 在你的场景里：
  - Handoffs 版链路：音频/文字需求 → Gem1 → Gem2 → 设计AI → Gem3。
  - Supervisor 版链路：
    - 新需求 → 先 Gem1，再 Gem2，再设计AI。
    - 仅 UI 微调 → 直接设计AI，甚至不需要 Gem3 文档。
    - 补写文档 → 可直接 Gem3，重用既有原型/功能规划。

#### 理解检查 (Comprehension Checks)

- **问题(Q1):** 用一句话概括 Supervisor 和 Handoffs 的核心区别？
- **我的回答(A1):** 一个是按部就班的固定流程，一个是按需选择适合路径的动态调度。
- **标记:** ✓ 正确
- **洞察:** 已能抓住本质：Handoffs = 固定路径，Supervisor = 动态路径选择。
- **理解程度:** 良好

- **问题(Q2):** 领导只改首页配色这种需求，在 Supervisor 模式下怎么处理更合理？
- **我的回答(A2):** 这种需求不需要经过 Gem1、Gem2，也不会体现在需求说明书里，直接交给设计AI设计一版就可以交差。
- **标记:** ✓ 正确
- **洞察:** 能自然把真实工作习惯映射到路由决策：纯视觉改动可直达设计AI。
- **理解程度:** 优秀

---

### 主题 2: Supervisor 的难点 —— 意图识别、多轮决策与边界

#### 我的问题/场景 (My Question/Scenario)
在理解了 Supervisor 的直觉后，意识到一个核心风险：
> 现在是用户原始需求直接交给 Supervisor 让它判断派给哪个 Gem。如果判错了，比如一个本来只要改 UI 的需求被误发给 Gem2，当成新功能规划，后面所有输出都可能跑偏。

希望弄清楚：
- Supervisor 最难的地方究竟是什么？
- 如何设计出"安全"的 Supervisor，既能走捷径，又不轻易走错路？

#### 我的初始理解 (My Initial Understanding)
- [✓] 直觉上觉得"意图识别"是最难的（入口分类错了，后面全错）。
- [ ] 但还没系统意识到：Supervisor 需要在整个多轮流程中反复决策，而不仅是入口判一次。
- [ ] 对"谁说了算"（Supervisor vs 各子 Agent）的边界还不清晰。

#### 提供的解释 (Explanation Given)
- 难点 1：入口难点 = 意图识别 + 任务分类。
  - 不只是看一句"你想干嘛"，而是要在很多细颗粒度任务中分类：新项目 / 小改动 / 纯 UI / 只补文档等。
  - 分类错了会导致：
    - 大需求被当成小改动 → 步骤不够，风险增大。
    - 小需求被当成大项目 → 流程太长，浪费时间和 Token。
- 难点 2：过程难点 = 多轮决策，而不是一次性决定。
  - Supervisor 不是只在第一步做路由决策，而是在每次拿到新结果时，都要决定下一步：
    - 继续补信息？
    - 进入下一层（功能 → 设计 → 文档）？
    - 还是回退到上一层？
- 难点 3：边界难点 = Supervisor 和下游 Agent 谁有最终决定权？
  - 如果 Supervisor 过软：谁说"可以了"就停，标准会混乱。
  - 如果 Supervisor 过硬：一味要求多轮验证，成本会爆炸。
  - 更好的设计是：让每个 Agent 暴露结构化"自检信号"，Supervisor 基于这些信号 + 全局规则做路由，而不是靠感觉拍脑袋。

#### 理解检查 (Comprehension Checks)

- **问题(Q):** 如果 Supervisor 把一个本来只要改 UI 的需求误发给 Gem2，当成新功能规划，会出现什么问题？
- **我的回答(A):** 路由判断错误会导致 Gem2 直接从功能角度展开设计，后续设计AI/Gem3 都跟着这个错误方向走，最后结果整体偏离了用户原始意图。
- **标记:** ✓ 正确
- **洞察:** 能清晰意识到"入口分流错"不是多走两步的问题，而是整个链路方向错。
- **理解程度:** 良好

---

### 主题 3: Supervisor 路由与纠错规则 —— 视觉白名单 + 功能自检信号

#### 我的问题/场景 (My Question/Scenario)
在理解难点之后，希望把自己的直觉规则固化下来，让 Supervisor 能够：
- 在"纯视觉改动"的场景下安全地走捷径，直接路由到设计AI；
- 在"功能/流程变更"的场景下，老老实实走 Gem1/Gem2；
- 在路由出现偏差时，能通过冲突识别和自检信号回退到 Gem2 修正。

#### 我的初始理解 (My Initial Understanding)
- [✓] 能给出直观规则：
  1. 当描述中只出现配色/排版/字号/布局、不出现"新增/删除某个功能"字眼时，直接转发给设计AI。
  2. Supervisor 在功能阶段应该检查：是否覆盖用户原始需求、产品逻辑是否闭环、是否与已有功能冲突。
- [ ] 但这两条还比较散，需要结构化成可以给 AI 实际执行的规则模板。

#### 提供的解释 (Explanation Given)

**1）视觉微调直达 DesignAI 的白名单规则**

- 触发条件（全部满足）：
  - 用户描述只涉及：
    - 配色 / 颜色风格
    - 排版 / 布局
    - 字号 / 间距
    - 视觉风格（科技感/大屏感等）
  - 且没有任何关于：
    - 新增/删除 功能/入口/模块/按钮/页面
    - 改流程/路径/步骤
    - 调整权限/业务规则
- 动作：
  - Supervisor 直接将需求派给设计AI，不调用 Gem1/Gem2。
  - 设计完成后，如果没有新的纠错信号，则可以结束本次任务。

**2）功能阶段的自检信号与放行条件**

- 要求 Gem2 输出以下自检信号：
  - `coverage_ok`：是否把用户原始需求都映射到功能上。
  - `logic_closed_ok`：功能和流程是否自洽闭环，没有"凭空出现"的输入/输出。
  - `conflict_ok`：是否与已有功能/体验无冲突。
  - `mvp_ready`：是否已经明确 V1 范围与取舍。
- Supervisor 的放行规则：
  - 若 `coverage_ok && logic_closed_ok && conflict_ok && mvp_ready` 全为 true：
    - 放行到设计AI（进入表现层）。
  - 否则：
    - 退回 Gem2，针对为 false 的项补强。
  - 特别地：
    - 若 `conflict_ok == false` → 视为"与已有功能有冲突"，必须退回 Gem2 修改，禁止进入设计AI。

**3）纠错机制：谁有权说"这路走错了"**

- Gem2 纠错：
  - 若 Gem2 发现这次需求本质上只是 UI 表达问题（功能不变），可以设置 `should_route_to_design_only = true`。
  - Supervisor 收到后，可将任务重新标记为"视觉改动为主"，直接路由到设计AI。
- 设计AI 纠错：
  - 若设计AI在绘制时发现涉及新增入口/改流程/改信息架构，可设置 `need_feature_planning = true`。
  - Supervisor 收到后，将任务转回 Gem2，让产品功能先想清楚，再继续设计。

#### 理解检查 (Comprehension Checks)

- **问题(Q1):** 什么时候可以放心跳过 Gem1/Gem2，直接把需求交给设计AI？
- **我的回答(A1):** 只有在我几乎能确定这是纯视觉改动、完全不动功能和流程的时候（只改配色/排版/字号/布局），才可以走这条直达路线；只要沾一点功能/流程的味道，一律走 Gem1/Gem2 正常链路。
- **标记:** ✓ 正确

- **问题(Q2):** 如果 `coverage_ok = true`、`logic_closed_ok = true`，但 `conflict_ok = false`，Supervisor 应该怎么做？
- **我的回答(A2):** 说明和现有功能/体验有冲突，不能直接进入设计AI，必须退回 Gem2 重新修改，让功能方案和既有系统对齐之后再放行。
- **标记:** ✓ 正确
- **洞察:** 能把"冲突回退"看作硬规则，而不是建议项。
- **理解程度:** 良好

#### 📊 本主题的流程图（Supervisor 路由与纠错）

```mermaid
graph TD
    U["用户需求"] --> S["Supervisor"]

    S -->|满足纯视觉改动白名单| D["设计AI"]
    S -->|其他情况| G1["Gem1 意图解析"]

    G1 --> G2["Gem2 功能规划"]
    G2 --> S2["Supervisor 功能阶段决策"]

    S2 -->|coverage_ok && logic_closed_ok && conflict_ok && mvp_ready| D
    S2 -->|任一为 false 或 conflict_ok == false| G2

    G2 -->|should_route_to_design_only == true| D

    D -->|need_feature_planning == true| G2

    D --> S3["Supervisor 收尾"]
    S3 --> OUT["结束并输出结果"]
```

---

### 补充：三类入口模式与两个典型场景

**三类入口：**

- **原始话术入口（raw_request）**: 输入是领导/业务方的原话或录音转写，尚未结构化；必须先经过 Gem1 做意图解析，再交给 Gem2。
- **已解析意图入口（after_intent）**: 输入是我或上一轮 AI 已整理好的意图/需求摘要（类似 `intent_decoded` 风格）；Supervisor 可以直接从 Gem2 开始，不必重复跑 Gem1。
- **纯视觉改动入口（visual_only）**: 输入只涉及配色/排版/字号/布局等视觉问题且不触及功能/流程；Supervisor 可直接路由到设计AI，跳过 Gem1/Gem2。

**两个典型场景回放：**

- **案例 A：首页改成蓝色系**: 顶层 Router 判断这是“做产品”而非“查知识”，Supervisor 检测到该需求只涉及视觉层 → 走 `visual_only` 入口 → 直接派给设计AI 出一版新首页，然后收工。
- **案例 B：电厂告警大屏**: 顶层 Router 判断为“产品工作流”，且需求包含新功能和新流程 → 走 `raw_request` 入口 → 依次经过 Gem1（拆潜台词/认知误区）和 Gem2（功能清单+用户旅程+MVP+自检信号），Supervisor 只有在 `coverage_ok`、`logic_closed_ok`、`conflict_ok`、`mvp_ready` 全部为 true 时才放行到设计AI，否则打回 Gem2 继续打磨。

---

## 3. 识别出的知识盲区与下次行动项

### 知识盲区表

| 主题 | 严重程度 | 备注 | 解决状态 |
|------|--------|------|--------|
| Supervisor 在具体框架（如 LangGraph）中的节点/边实现方式 | 中 | 目前只在概念和规则层面清晰，还没有在真实框架里实现过 Supervisor 节点和路由逻辑 | 未解决 |
| Supervisor 与现有 RAG 系统的意图分流（检索/生成/改写等）如何融合 | 中 | 需要把今天的路由心智模型嫁接到已有的 RAG 意图识别与分流策略上 | 未解决 |

### 🎯 针对上述盲区的下次行动项

- [ ] **落地到具体框架：Supervisor 实现练习**
  - 选择一个熟悉的框架（优先 LangGraph），按照今天的规则设计一个最小可用的 Supervisor 节点。
  - 用简单的三 Agent 场景（Gem1/Gem2/DesignAI）模拟路由与回退。

- [ ] **与 RAG 意图分流整合**
  - 复盘现有 RAG 系统中的意图分类逻辑（检索回答 vs 总结 vs 改写 vs 任务分解）。
  - 思考在这些意图下，Supervisor 应该如何参与：哪些交给检索层，哪些交给多 Agent 编排层。

### 📋 行动项-盲区映射

| 行动项 | 对应盲区 | 优先级 |
|--------|--------|--------|
| Supervisor 实现练习 | Supervisor 在具体框架中的实现方式 | 高 |
| 与 RAG 意图分流整合 | Supervisor 与 RAG 系统一起工作的问题 | 中 |

---

## 4. 本次掌握的主题总结 (Topics Mastered Today)

| 主题 | 信心指数 | 备注 | 来源 |
|------|--------|------|------|
| Supervisor vs Handoffs 的本质区别 | 良好 | 能用"固定流程 vs 按需路径"概括两者差异，并能结合实际工作流举例说明 | 主题1 理解检查 |
| Supervisor 路由与纠错心智模型 | 良好 | 建立起"视觉白名单直达设计AI + 功能自检信号放行 + 冲突回退到Gem2 + 子Agent举手纠错"的一整套决策逻辑 | 主题2/3 理解检查 |
| Supervisor system prompt 设计能力 | 一般 | 能围绕角色设定/输入信号/路由规则/纠错机制写出一份可用的 Supervisor prompt 草稿，后续需要在真实框架中验证和迭代 | 主题3 Prompt 模板整理 |
